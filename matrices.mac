/* vim: ft=maxima
*/
/* does the matrix have an all-zero row? Return the index of the highest
 * one if it exists, and -1 if there's no zero row */

hasZeroRow(a) := block([width, height, i, output],
    height : matrix_size(a)[1],
    width : matrix_size(a)[2],
    output : -1,
    for i thru height do (
        if (apply('matrix, [a[i]]) = zeromatrix(1, width)) 
            then (output : i, return())),
    output
);
/*
hasZeroRow(a) := block([width, height, i, output], height : matrix_size(a)[1], width : matrix_size(a)[2], output : -1, for i thru height do ( if (apply('matrix, [a[i]]) = zeromatrix(1, width)) then (output : i, return())), output);
*/

/* returns true if there is a zero row with a nonzero row below it,
 * otherwise false */

zeroRowsNotAllAtBottom(a) := block([zr, sm, i],
    zr : hasZeroRow(a),
    if (zr = -1) then return(false),
    sm : apply(submatrix, append(makelist(i, i, 1, zr - 1), [a])),
    return(not is(sm = zeromatrix(matrix_size(sm)[1], matrix_size(sm)[2])))
);
/*
zeroRowsNotAllAtBottom(a) := block([zr, sm, i], zr : hasZeroRow(a), if (zr = -1) then return(false), sm : apply(submatrix, append(makelist(i, i, 1, zr - 1), [a])), return(not is(sm = zeromatrix(matrix_size(sm)[1], matrix_size(sm)[2]))));
*/


/* return the coordinates of a non-1 leading entry, or [-1, -1]
 * if none exists */

nonOneLeadingEntry(a) := block([height, i, c, output],
    height : matrix_size(a)[1],
    output : [-1, -1],
    for i thru height do (
        c : columnOfLeadingEntry(a, i),
        if ((c # -1) and (a[i][c] # 1)) then (output : [i, c], return())),
    output
);
/*
nonOneLeadingEntry(a) := block([height, i, c, output], height : matrix_size(a)[1], output : [-1, -1], for i thru height do ( c : columnOfLeadingEntry(a, i), if ((c # -1) and (a[i][c] # 1)) then (output : [i, c], return())), output);
*/

/* returns the coordinates of a leading entry such that there is a
 * nonzero entry somewhere else in its column if such a leading entry
 * exists, otherwise returns [-1, -1] */

nonZeroEntryInColumnOfLeadingEntry(a) := block([height,output, i, ii, c],
    height : matrix_size(a)[1],
    output : [-1, -1],
    for i thru height do (
        c : columnOfLeadingEntry(a, i),
        if (c # -1) then (
            for ii thru height do (
                if ((ii # i) and (a[ii][c] # 0)) then (output : [i, c], return())))),
    output
);
/*
nonZeroEntryInColumnOfLeadingEntry(a) := block([height,output, i, ii, c], height : matrix_size(a)[1], output : [-1, -1], for i thru height do ( c : columnOfLeadingEntry(a, i), if (c # -1) then ( for ii thru height do ( if ((ii # i) and (a[ii][c] # 0)) then (output : [i, c], return())))), output);
*/

/* return [i, j] such that i < j and the leading entry in row j is not
 * strictly to the right of the leading entry in row i, if such a pair
 * exists, otherwise return [-1, -1] */

badLeadingEntryPositions(a) := block([height, i, c, ii, output, cc],
    height : matrix_size(a)[1],
    output : [-1, -1],
    for i thru (height - 1) do (
        c : columnOfLeadingEntry(a, i),
        if (c # -1) then (
            for ii : (i + 1) while ii <= height do (
                cc : columnOfLeadingEntry(a, ii),
                if ((cc # -1) and (cc <= c)) then
                    (output : [i, ii], return())))),
    output
    );
/*
badLeadingEntryPositions(a) := block([height, i, c, ii, output, cc], height : matrix_size(a)[1], output : [-1, -1], for i thru (height - 1) do ( c : columnOfLeadingEntry(a, i), if (c # -1) then ( for ii : (i + 1) while ii <= height do ( cc : columnOfLeadingEntry(a, ii), if ((cc # -1) and (cc <= c)) then (output : [i, ii], return())))), output);
*/

/* return the first column of a with a nonzero entry in row i if this exists,
 * otherwise -1 */
columnOfLeadingEntry(a, i) := block([q, l, j],
    q : matrix_size(a)[2],
    l : -1,
    for j thru q do (
        if not(a[i, j] = 0) then (l : j, return())
        ),
    l
);
/*
columnOfLeadingEntry(a, i) := block([q,l], q:matrix_size(a)[2], l : -1, for j thru q do (if not(a[i,j] = 0) then (l : j, return())), l);
*/

/* compute the row reduced echelon form of a */
rref(a) := block([p, l, i, j],
    p : matrix_size(a)[1],
    a : echelon(a),
    for i : 2 thru p do
        (l : columnOfLeadingEntry(a,i),
        if l > 0 then (
            for j thru i - 1 do
                a : rowop(a, j, i, a[j, l])
            )
        ),
    a
);
/*
rref(a) := block([p, l], p:matrix_size(a)[1], a : echelon(a), for i : 2 thru p do (l : columnOfLeadingEntry(a,i), if l > 0 then (for j thru i - 1 do a : rowop(a, j, i, a[j, l]))), a);
*/

 
/* return true if the matrix a is in row reduced echelon form, otherwise
 * false */
isrref(a) := is(a = rref(a));

/* return true if the matrix a is diagonal, otherwise false */
isdiag(a) := block([li, i],
    li : makelist(a[i][i], i, 1, min(matrix_size(a)[1], matrix_size(a)[2])),
    is(a = apply(diag_matrix, li))
);
/*
isdiag(a) := block([li, i], li : makelist(a[i][i], i, 1, min(matrix_size(a)[1], matrix_size(a)[2])), is(a = apply(diag_matrix, li)));
*/

/* return true if all entries of a are zero */
iszeromx(a) := is(a = zeromatrix(matrix_size(a)[1], matrix_size(a)[2]));

/* return true if v is an eigenvector of a */
isevec(v,a) :=  not(iszeromx(v)) and is(rank(addcol(v, a.v)) = 1); 


/* row ops */

/* lij(a,l,i,j) adds l times row i to row j of a */
lij(a, l, i, j) := block(a[j] : l* a[i] + a[j]);

/* sw(a,i,j) swaps rows i and j of a */
sw(a,i,j) := block(temp : a[i], a[i] : a[j], a[j] : temp);

/* mu(a,i,l) multiplies row i of a by l */
mu(a,i,l) := block(a[i] : l * a[i]);

/* isLI(v1, v2, ...) is true if the vectors vi are linearly independent,
 * otherwise false */
isLI([vecs]) := block([n,m],
    n : length(vecs),
    m : apply(addcol, vecs),
    is(n = rank(m))
);
/*
isLI([vecs]) := block([n,m], n : length(vecs), m : apply(addcol, vecs), is(n = rank(m)));
*/

/* we represent a subspace by matrix whose columns are a spanning set
 * for the subspace. */

/* dim is an alias for rank */
dim(a) := rank(a);

/* create all of R^n */
fullColumnSpaceOfDimension(n) := ident(n);

/* create the zero subspace of R^n */
zeroSubspace(n) := zeromatrix(n, 1);

/* are the subspaces rep by a and b equal? */
equal_subspaces(a,b) := block([ra, rb, rab],
    if (matrix_size(a)[1] # matrix_size(b)[1])
        then return(false),
    ra : rank(a),
    rb : rank(b),
    rab : rank(mat_unblocker(matrix([a,b]))),
    is(ra = rb and ra = rab)
);
/*
equal_subspaces(a,b) := block([ra, rb, rab], if (matrix_size(a)[1] # matrix_size(b)[1]) then return(false), ra : rank(a), rb : rank(b), rab : rank(mat_unblocker(matrix([a,b]))), is(ra = rb and ra = rab));
*/

/* return a matrix whose columns are a basis for the subspace
 * represented by a, unless a is the zero matrix in which case return a
 * column of zeroes.  */
refine(a) := block([s],
    if (a = zeromatrix(matrix_size(a)[1], matrix_size(a)[2]))
        then return (zeromatrix(matrix_size(a)[1], 1)), 
    s : args(columnspace(a)),
    apply(addcol, s)
);
/*
refine(a) := block([s], if (a = zeromatrix(matrix_size(a)[1], matrix_size(a)[2])) then return (zeromatrix(matrix_size(a)[1], 1)), s : args(columnspace(a)), apply(addcol, s));
*/

/* compute transpose(a).a and wrap the result as a matrix if necessary - 
 * maxima converts 1x1 matrices to numbers, we don't want this */
safeAtA(a) := block(
    if (matrix_size(a)[2] = 1)
        then return(matrix([transpose(a).a])),
    transpose(a). a
);
/*
safeAtA(a) := block(if (matrix_size(a)[2] = 1) then return(matrix([transpose(a).a])), transpose(a). a);
*/


/* orthogonal projection onto column space of a matrix a whose
 * columns are assumed linearly independent */
proj(a) := block([aa],
    aa : refine(a),
    aa . invert(safeAtA(aa)) . transpose(aa)
);
/*
proj(a) := block([aa], aa : refine(a), aa . invert(safeAtA(aa)) . transpose(aa));
*/


/* is the column space as big as possible? */
spansWholeSpace(a) := is(rank(a) = matrix_size(a)[1]);

/* take a matrix, return matrix representation of its kernel. Don't call
 * this on matrices with zero kernel */
kerMX(a) := apply(addcol, args(nullspace(a)));

/* take the matrix representations a and b of two subspaces A and B,
 * return the matrix rep of A \cap B */
sum_subspacesMX(a,b) := mat_unblocker(matrix([a,b]));

/* compute a matrix representation for the intersection of the subspaces
 * represented by the matrices a and b. The idea is to use the fact that
 * the kernel of
 * [ X ]
 * [ Y ]
 * is the intersection of the kernels of X and Y, so we only have to
 * produce a matrix whose kernel is the column space (image) of a.
 * If A has columns spanning
 *   ker (a^T)= im(a)^\perp
 * then 
 *   ker A^T = im a
 * (certainly im a is contained in ker A^T, then check dimensions). 
 * So we return the kernel of
 * [ A^T ]
 * [ B^T ]
 */
intersect_subspacesMX(a,b) := block([x, y, z],
    if spansWholeSpace(a)
        then return (b)
    else if spansWholeSpace(b)
        then return (a),
    x : kerMX(transpose(a)),
    y : kerMX(transpose(b)),
    z : mat_unblocker(matrix([transpose(x)], [transpose(y)])),
    kerMX(z)
);
/*
intersect_subspacesMX(a,b) := block([x, y, z], if spansWholeSpace(a) then return (b) else if spansWholeSpace(b) then return (a), x : kerMX(transpose(a)), y : kerMX(transpose(b)), z : mat_unblocker(matrix([transpose(x)], [transpose(y)])), kerMX(z));
*/

/* is this vector v in this subspace a? */
inn(v, a) := is(rank(a) = rank(addcol(v,a)));

/* random permutation matrix */
rpm(n) := block([z, l, p, i], 
    z : zeromatrix(n,n),
    l : makelist(i,i,1,n),
    p : random_permutation(l),
    for i : 1 thru n do 
        z[i][p[i]] : 1,
    z
);
/*
rpm(n) := block([z, l, p, i], z : zeromatrix(n,n), l : makelist(i,i,1,n), p : random_permutation(l), for i : 1 thru n do z[i][p[i]] : 1, z);
*/

/* random lower unitriangular matrix with entries in -maxi...maxi */
random_lut_mx(n, maxi) := block([id, i, j],
    id : ident(n),
    for i : 2 thru n do (
        for j : 1 thru i-1 do (
            id[i][j] : random(maxi + 1) * (-1)^random(2)
            )
        ),
    id
);
/*
random_lut_mx(n, maxi) := block([id, i, j], id : ident(n), for i : 2 thru n do ( for j : 1 thru i-1 do ( id[i][j] : random(maxi + 1) * (-1)^random(2))), id);
*/

/* random element of SL_n(Z) */
random_slnz(n, maxi) := random_lut_mx(n, maxi) . rpm(n) . random_lut_mx(n, maxi);
