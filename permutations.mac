/* vim: ft=maxima
*/

/* given a permutation of N things as a list of disjoint cycles, convert
 * it to (the bottom row of) the two-row rep */
cyclesTo2Row(cycs, N) := block([output, i, j, cyc, f, nxt, current],
    output : makelist(i, i, 1, N),
    for i : 1 thru length(cycs) do (
        cyc : cycs[i],
        f : first(cyc),
        current : first(cyc),
        for j : 2 thru length(cyc) do (
            nxt : cyc[j],
            output[current] : nxt,
            current : nxt
        ),
        output[current] : f
    ),
    output 
); 

/* given a single cycle as a list, return its two-row representation
 */
cycleTo2Row(cycle, N) := block([output, i],
    output : makelist(i, i, 1, N),
    for i : 1 thru length(cycle) - 1 do(
        output[cycle[i]] : cycle[i + 1]
        ),
    output[last(cycle)] : first(cycle),
    output
);

/* identity permutation of N letters in two-row notation */
id_tworow(N) := makelist(i, i, 1, N);

/* right fold */
foldr(list, fn, default) := if length(list) = 0 then default else fn(first(list), foldr(rest(list), fn, default));


/* convert two-row notation to a list of disjoint cycles */
twoRowToCycles(tworow) := block([unseen, i, output, count, cycle_start, dummy, current_cyc, current],
    unseen : makelist(i, i, 1, length(tworow)),
    output : [],
    for count : 1 while length(unseen) > 0 do (
        cycle_start : unseen[1],
        unseen : delete(cycle_start, unseen),
        current_cyc : [cycle_start],
        current : cycle_start,
        for dummy : 1 while (not is(tworow[current] = cycle_start)) do (
            current : tworow[current],
            unseen : delete(current, unseen),
            current_cyc : append(current_cyc, [current])
            ),
        if length(current_cyc) > 1 then output : append(output, [current_cyc])
        ),
    output
);

/* is cycs, a list of cycles, disjoint? */
disjointCyclesp(cycs) := block([lengths, sumlengths, sets, allelts],
    lengths : maplist(length, cycs),
    sumlengths : apply("+", lengths),
    sets : maplist(setify, cycs),
    allelts : apply(union, sets),
    is(sumlengths = cardinality(allelts))
);

/* is li a legitimate cycle whose elements come from 1..N? */
cyclep(li, N) := block([validentries, answer, i, valid, x, alldist, allvalid],
    answer : false,
    if listp(li) then (
        validentries : makelist(i, i, 1, N),
        valid(x) := member(x, validentries),
        alldist : is(length(li) = cardinality(setify(li))),
        allvalid : all_listp(valid, li),
        answer : alldist and allvalid
    ),
    answer
);
    
/* is li a legitimate permutation of 1..N given as a list of
 * cycles?
 */
permAsCycsp(li, N) := block([answer, val],
    answer : false,
    if listp(li) then (
        val(x) := cyclep(x, N),
        answer : all_listp(val, li)
        ),
    answer
);

/* order of the permutation cycs given as a list of disjoint cycles */
order_dj_cycs(cycs) := lcm(maplist(length, cycs));

/* order of the permutation tworow given in two-row form */
order_tworow(tworow) := order_dj_cycs(twoRowToCycles(tworow));

/* inverse of the permutation cycs given as a list of possibly
 * non-disjoint cycles, output in cycle form. If the input cycles are
 * disjoint, so are the output cycles.
 */
inverseCycles(cycs) := reverse(maplist(reverse, cycs));

/* inverse of the permutation tworow given in two-row form, output in
 * two-row form
 */
inverseTwoRow(tworow) := cyclesTo2Row(inverseCycles(twoRowToCycles(tworow)), length(tworow));

/* sign of the permutation cycs given as a list of possibly non-disjoint
 * cycles
 */
sgn_cycles(cycs) := (-1) ** (length(cycs) + apply("+", maplist(length, cycs)));

/* sign of the permutation tworow given in two-row form */
sgn_tworow(tworow) := sgn_cycles(twoRowToCycles(tworow));

/* compose the two permutations tr1 and tr2 given in two-row form,
 * returning the result in two-row form
 */
compose_tworow(tr1, tr2) := makelist(tr1[tr2[i]], i, 1, length(tr1));

/* convert any list of cycles, even if non-disjoint, to its two-row
 * notation
 */
cyclesTo2Row2(cycs, N) := foldr(maplist(lambda([cyc], cycleTo2Row(cyc, N)), cycs), compose_tworow, id_tworow(N));

/* compose the two permutations c1, c2 of N things, given as lists of
 * disjoint cycles, outputting the result in disjoint cycle form
 */
compose_cycs(c1, c2, N) := twoRowToCycles(compose_tworow(cyclesTo2Row2(c1, N), cyclesTo2Row2(c2, N)));


/* tworow ^ n, where n is nonnegative and tworow is the two-row rep of a
 * perm
 */
nonneg_power_tworow(tworow, n) := foldr(makelist(tworow, i, 1, n), compose_tworow, id_tworow(length(tworow)));

/* tworow^n, where n is an integer and tworow is the two-row rep of a
 * perm
 */
power_tworow(tworow, n) := if n >= 0 then nonneg_power_tworow(tworow, n) else nonneg_power_tworow(inverseTwoRow(tworow), -n);

/* input: a cycle cyc. Output: a list of transpositions whose product is
 * cyc.
 */
cycle_to_transpositions(cyc) := block([output, i],
    output : [],
    for i : 1 thru length(cyc) - 1 do (
        output : append(output, [[cyc[i], cyc[i + 1]]])
        ),
    output
);

/* convert a list of cycles to a list of transpositions whose product
 * equals the product of the original list
 */
cycles_to_transpositions(cycs) := apply(append, maplist(cycle_to_transpositions, cycs));

/* produce latex rep of this two-row perm */
twoRowLaTeX(tworow) := block([n, str, i],
    n : length(tworow),
    str : "\\begin{pmatrix}",
    for i : 1 thru n-1 do (
        str : sconcat(str, i, "& ")
        ),
    str : sconcat(str, n, "\\\\"),
    for i : 1 thru n-1 do (
        str : sconcat(str, tworow[i], "& ")
        ),
    str : sconcat(str, tworow[n], "\\end{pmatrix}"),
    str
);

/* produce latex rep of a cycle */
cycleLaTeX(cyc) := block([i, str],
    str : "(",
    for i : 1 thru length(cyc) - 1 do (
        str : sconcat(str, cyc[i], ", ")
    ),
    str : sconcat(str, last(cyc), ")"),
    str
);
/* produce latex rep of this list of cycles */
cyclesLaTeX(cycs) := block([str, i],
    str : "",
    for i : 1 thru length(cycs) do (
        str : sconcat(str, cycleLaTeX(cycs[i]))
        ),
    str
);

/* generate a random perm in 2-row notation */
randomPerm(n) := rand_selection(makelist(i, i, 1, n), n);





/********************************************************************/
/* some code for permutation groups added by John Talbot Sep 12 2020*/
/* mainly to allow STACK questions on permutation groups.           */
/********************************************************************/

/* compose a list of perms given as two-rows */
mult_2rows(listof2rows):=foldr(listof2rows,compose_tworow,makelist(i,i,1,length(first(listof2rows))));


/* generate a permutation group (returns a set of tworow perms) from a given set of tworow permtutation generators */

generateGroup(gens):=block([group,oldsize],group:gens, oldsize:cardinality(group)-1,
    while cardinality(group)>oldsize do ( oldsize:cardinality(group),
        for a in gens do ( for b in group do group:union({mult_2rows([a,b]),mult_2rows([b,a])},group))        
    ),
    group
);

/* order defined for non-STACK maxima (ie without lcm). */

order(perm):=cardinality(generateGroup({perm}));


/* Check if cyclic: find orders of elements and check if any match order of group*/

isCyclic(group):=is(elementp(cardinality(group),map(order,group)));


/* check a given (sub)set of permutations is a (sub)group */

setIsGroup(S):=block([pairs:powerset(rest(S),2),isgroup:true],
     if not(elementp(id_tworow(length(first(S))),S)) then isgroup:false,                /* check identity is present first */
     for x in S while (isgroup) do (                                                    /* check all powers of elements are present and hence inverses*/
         if not(subsetp(generateGroup({x}),S)) then isgroup:false
     ),
     for p in pairs while (isgroup) do (                                               /* finally check x*y and y*x are both present for each x\neq y */
         if not(subsetp(generateGroup({first(p),last(p)}),S)) then isgroup:false
     ),
     isgroup
);

/* given a group (as a set of tworow permutations) return a set containing all subgroups
start with trivial subgroup then add cyclic subgroups and test for cyclicity.  If not start considering generating sets of size 2 up to D 
  using the fact that any proper subgroup H of G has a generating set of size at most D=\lfloor \log_2(|G|/min_prime_divisor(|G|))\rfloor.*/

generateSubgroups(group):=block([group:group,g,D,N:cardinality(group),subgroups],subgroups:{{first(group)}},
    for g in rest(group) do subgroups:adjoin(generateGroup({g}),subgroups), 
    if elementp(group,subgroups) then D:1 else  (subgroups:adjoin(group,subgroups), D:floor(log(N/second(divisors(N)))/log(2))),
    for i: 2 thru D do (
        for g in powerset(rest(group),i) do ( subgroups:adjoin(generateGroup(g),subgroups)) 
    ),
    subgroups
);



/* cyclic group C_N as a permutation group in the obvious way 
	i.e. generated by gen= 1->2->3...->N->1 */

cyclicGroup(N):=block(genx:append(makelist(i+1,i,1,N-1),[1]), generateGroup({genx}));

/* dihedral group of order 2n */

dihedralGroup(N):=block( genx:append(makelist(i+1,i,1,N-1),[1]), geny : makelist(N-i+1,i,1,N), generateGroup({genx,geny}));

/* symmetric group degree N */
symmetricGroup(N):=permutations(makelist(i,i,1,N));

/* alternating group of degree N */
alternatingGroup(N):=block(
    S:symmetricGroup(N),
    group:{},
    for p in S do (
        if sgn_tworow(p)=1 then group : adjoin(p, group)
    ),
    group
);

